// Simple Pong game
// Left paddle: player (mouse + ArrowUp/ArrowDown)
// Right paddle: computer AI
// Canvas-based implementation

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreboardPlayer = document.getElementById('playerScore');
  const scoreboardComputer = document.getElementById('computerScore');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  // Game dimensions (canvas is fixed by HTML attributes; on small screens CSS scales it)
  const W = canvas.width;
  const H = canvas.height;

  // Paddles
  const PADDLE_WIDTH = 14;
  const PADDLE_HEIGHT = 100;
  const PADDLE_SPEED = 6.5; // keyboard speed
  const AI_MAX_SPEED = 5.0; // computer top speed

  // Ball
  const BALL_RADIUS = 9;
  const BALL_INITIAL_SPEED = 5;
  const BALL_SPEED_INCREMENT = 0.15;
  const MAX_BALL_SPEED = 14;

  // State
  let playerScore = 0;
  let computerScore = 0;
  let paused = false;

  const player = {
    x: 14,
    y: (H - PADDLE_HEIGHT) / 2,
    w: PADDLE_WIDTH,
    h: PADDLE_HEIGHT,
    dy: 0
  };
  const computer = {
    x: W - PADDLE_WIDTH - 14,
    y: (H - PADDLE_HEIGHT) / 2,
    w: PADDLE_WIDTH,
    h: PADDLE_HEIGHT
  };

  const ball = {
    x: W / 2,
    y: H / 2,
    r: BALL_RADIUS,
    vx: 0,
    vy: 0,
    speed: BALL_INITIAL_SPEED
  };

  // Keyboard state
  const keys = { ArrowUp: false, ArrowDown: false };

  // Init
  function resetBall(toPlayerServe = false) {
    ball.x = W / 2;
    ball.y = H / 2;
    ball.speed = BALL_INITIAL_SPEED;

    // random angle between -30 and 30 degrees
    const angleDeg = (Math.random() * 60 - 30);
    const angle = (angleDeg * Math.PI) / 180;
    const dir = toPlayerServe ? -1 : (Math.random() < 0.5 ? -1 : 1);
    ball.vx = dir * ball.speed * Math.cos(angle);
    ball.vy = ball.speed * Math.sin(angle);
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // Collision detection: circle vs rect (paddle)
  function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
    // Find closest point to circle within rectangle
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) <= (r * r);
  }

  // Update loop
  function update() {
    if (paused) return;

    // Player paddle: keyboard
    if (keys.ArrowUp) player.y -= PADDLE_SPEED;
    if (keys.ArrowDown) player.y += PADDLE_SPEED;

    // Keep player inside bounds
    player.y = clamp(player.y, 0, H - player.h);

    // Computer AI: track ball with limited speed and a little "deadzone"
    const paddleCenter = computer.y + computer.h / 2;
    const delta = ball.y - paddleCenter;
    const aiSpeed = Math.min(AI_MAX_SPEED, Math.abs(delta) * 0.12 + 1.1); // dynamic but bounded
    if (Math.abs(delta) > 8) {
      computer.y += (delta > 0 ? aiSpeed : -aiSpeed);
    }
    // keep inside
    computer.y = clamp(computer.y, 0, H - computer.h);

    // Move ball
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Collide with top / bottom walls
    if (ball.y - ball.r <= 0) {
      ball.y = ball.r;
      ball.vy = -ball.vy;
    } else if (ball.y + ball.r >= H) {
      ball.y = H - ball.r;
      ball.vy = -ball.vy;
    }

    // Paddle collisions
    // Player (left)
    if (ball.vx < 0 && circleRectCollision(ball.x, ball.y, ball.r, player.x, player.y, player.w, player.h)) {
      // Place ball outside paddle to avoid sticking
      ball.x = player.x + player.w + ball.r;
      reflectOffPaddle(player);
    }

    // Computer (right)
    if (ball.vx > 0 && circleRectCollision(ball.x, ball.y, ball.r, computer.x, computer.y, computer.w, computer.h)) {
      ball.x = computer.x - ball.r;
      reflectOffPaddle(computer);
    }

    // Scoring
    if (ball.x + ball.r < 0) {
      // computer scores
      computerScore += 1;
      scoreboardComputer.textContent = computerScore;
      flashScoreboard('computer');
      // reset, serve towards player
      resetBall(true);
    } else if (ball.x - ball.r > W) {
      // player scores
      playerScore += 1;
      scoreboardPlayer.textContent = playerScore;
      flashScoreboard('player');
      resetBall(false);
    }
  }

  function reflectOffPaddle(paddle) {
    // Increment speed slightly
    ball.speed = Math.min(MAX_BALL_SPEED, ball.speed + BALL_SPEED_INCREMENT);

    // Determine hit position relative to paddle center (-1 to 1)
    const relY = (ball.y - (paddle.y + paddle.h / 2)) / (paddle.h / 2);
    const maxBounceAngle = 75 * Math.PI / 180; // in radians
    const angle = relY * maxBounceAngle;

    // Determine direction: ball should go away from paddle
    const dir = (paddle.x < W / 2) ? 1 : -1;

    ball.vx = dir * ball.speed * Math.cos(angle);
    ball.vy = ball.speed * Math.sin(angle);

    // Small nudge so it doesn't re-collide immediately
    ball.x += ball.vx * 0.5;
  }

  // Draw loop
  function draw() {
    // Clear
    ctx.clearRect(0, 0, W, H);

    // Background (soft)
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0, 0, W, H);

    // Middle dashed line
    ctx.strokeStyle = 'rgba(125,211,252,0.12)';
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 14]);
    ctx.beginPath();
    ctx.moveTo(W / 2, 0);
    ctx.lineTo(W / 2, H);
    ctx.stroke();
    ctx.setLineDash([]);

    // Paddles
    drawRoundedRect(player.x, player.y, player.w, player.h, 6, '#7dd3fc');
    drawRoundedRect(computer.x, computer.y, computer.w, computer.h, 6, '#7dd3fc');

    // Ball
    ctx.beginPath();
    const gradient = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 2, ball.x, ball.y, ball.r + 6);
    gradient.addColorStop(0, '#ffffff');
    gradient.addColorStop(0.2, '#dbefff');
    gradient.addColorStop(1, '#8ecae6');
    ctx.fillStyle = gradient;
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    // Optional small motion blur tail (very subtle)
    ctx.fillStyle = 'rgba(125,211,252,0.02)';
    ctx.fillRect(ball.x - ball.vx * 3, ball.y - ball.vy * 3, ball.r * 2, ball.r * 2);
  }

  function drawRoundedRect(x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Animation
  let lastTime = 0;
  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    update();
    draw();

    requestAnimationFrame(loop);
  }

  // Input: mouse
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleY = canvas.height / rect.height;
    const mouseY = (e.clientY - rect.top) * scaleY;
    player.y = clamp(mouseY - player.h / 2, 0, H - player.h);
  });

  // Hide cursor when over canvas (already set in CSS), but show if paused
  canvas.addEventListener('mouseenter', () => {
    if (!paused) canvas.style.cursor = 'none';
  });
  canvas.addEventListener('mouseleave', () => {
    canvas.style.cursor = 'default';
  });

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      keys[e.key] = true;
      e.preventDefault();
    } else if (e.key === ' ' || e.key === 'Spacebar') {
      // Toggle pause
      togglePause();
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      keys[e.key] = false;
      e.preventDefault();
    }
  });

  // Buttons
  restartBtn.addEventListener('click', () => {
    playerScore = 0;
    computerScore = 0;
    scoreboardPlayer.textContent = playerScore;
    scoreboardComputer.textContent = computerScore;
    resetBall(Math.random() < 0.5);
    paused = false;
    pauseBtn.textContent = 'Pause';
  });

  pauseBtn.addEventListener('click', () => {
    togglePause();
  });

  function togglePause() {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    canvas.style.cursor = paused ? 'default' : 'none';
  }

  function flashScoreboard(who) {
    const el = who === 'player' ? scoreboardPlayer : scoreboardComputer;
    el.animate([
      { transform: 'scale(1.0)', color: 'var(--accent)' },
      { transform: 'scale(1.18)', color: '#fff' },
      { transform: 'scale(1.0)', color: 'var(--accent)' }
    ], { duration: 420, easing: 'ease-out' });
  }

  // Start game
  resetBall(Math.random() < 0.5);
  requestAnimationFrame(loop);

  // Ensure canvas is focusable to capture keys on some browsers
  canvas.addEventListener('click', () => canvas.focus());

  // Expose nothing globally
})();
